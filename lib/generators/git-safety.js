const os = require('os');
const path = require('path');

/**
 * Generates git safety configurations for Claude Code 2.0
 * Prevents common destructive git operations that lose work
 */

/**
 * Main generator function
 */
function generateGitSafety(analysis, options = {}) {
  return {
    hooks: generateGitHooks(),
    commands: generateSafeGitCommands(),
    permissions: generateGitPermissions(),
    claudeMdSection: generateGitProtocol()
  };
}

/**
 * Generate PreToolUse hooks for git operations
 */
function generateGitHooks() {
  const homeDir = os.homedir();
  const hookPath = path.join(homeDir, '.claude', 'hooks', 'git-safety-check.sh');

  return {
    "PreToolUse": [{
      "matcher": "Bash",
      "hooks": [{
        "type": "command",
        "command": `"${hookPath}" "$CLAUDE_TOOL_ARGS"`,
        "timeout": 5,
        "continueOnError": false
      }]
    }]
  };
}

/**
 * Generate git permission tiers
 */
function generateGitPermissions() {
  const homeDir = os.homedir();
  const hookPath = path.join(homeDir, '.claude', 'hooks', 'git-safety-check.sh');

  return {
    allow: [
      // Git safety hook needs to run without prompts
      `Bash("${hookPath}":*)`,

      // Safe git operations
      "Bash(git status:*)",
      "Bash(git diff:*)",
      "Bash(git log:*)",
      "Bash(git show:*)",
      "Bash(git branch:*)",
      "Bash(git branch --show-current:*)",
      "Bash(git tag:*)",
      "Bash(git remote:*)",
      "Bash(git add:*)",
      "Bash(git commit -m:*)",
      "Bash(git stash:*)",
      "Bash(git stash push:*)",
      "Bash(git stash pop:*)",
      "Bash(git stash list:*)"
    ],
    ask: [
      "Bash(git reset:*)",
      "Bash(git clean:*)",
      "Bash(git push --force:*)",
      "Bash(git push -f:*)",
      "Bash(git branch -D:*)"
    ],
    deny: [
      "Bash(git reset --hard:*)",   // Use /safe-reset instead
      "Bash(git clean -fd:*)",       // Too dangerous - deletes untracked files
      "Bash(git clean -fdx:*)"       // Even more dangerous
    ]
  };
}

/**
 * Generate safe git command templates
 */
function generateSafeGitCommands() {
  return {
    'safe-switch': SAFE_SWITCH_TEMPLATE,
    'safe-commit': SAFE_COMMIT_TEMPLATE,
    'safe-reset': SAFE_RESET_TEMPLATE,
    'git-safety-status': GIT_SAFETY_STATUS_TEMPLATE
  };
}

/**
 * Generate CLAUDE.md git protocol section
 */
function generateGitProtocol() {
  return `
## GIT SAFETY PROTOCOL (MANDATORY)

Before EVERY git operation, you MUST:

### Pre-Flight Checks
- [ ] Run \`/git-safety-status\` first
- [ ] Review ALL output completely
- [ ] Verify current branch is correct

### Branch Operations
- [ ] Use \`/safe-switch <branch>\` instead of \`git checkout\`
- [ ] Stash uncommitted work automatically
- [ ] Verify you're on intended branch after switch

### Commit Operations
- [ ] Use \`/safe-commit "message"\` to see full scope
- [ ] Review staged vs unstaged files
- [ ] Confirm you're committing intended changes only

### Destructive Operations (reset, clean, force push)
- [ ] Create backup branch: \`git branch backup-$(date +%s)\`
- [ ] Use safe alternatives: \`/safe-reset <commit>\`
- [ ] Verify what will be lost before proceeding
- [ ] NEVER use \`git reset --hard\` (blocked by permissions)

## Recovery Procedures

If something goes wrong:
\`\`\`bash
# Find lost commits
git reflog

# Recover from reflog
git checkout <commit-hash>

# Recover from backup branch
git checkout backup-<timestamp>

# List stashed work
git stash list

# Recover stash
git stash pop stash@{0}
\`\`\`
`;
}

/**
 * Git safety check hook script template
 */
const GIT_SAFETY_HOOK_TEMPLATE = `#!/bin/bash
# Git Safety Check Hook
# Generated by ccxl v2.0.0
# Prevents dangerous git operations without safety measures

COMMAND="$1"

# Color codes for output
RED='\\033[0;31m'
YELLOW='\\033[1;33m'
GREEN='\\033[0;32m'
NC='\\033[0m' # No Color

# Check for dangerous git patterns
if echo "$COMMAND" | grep -qE "git (reset --hard|clean -fd|checkout [^-]|branch -D|push --force)"; then

    echo -e "\${YELLOW}‚ö†Ô∏è  GIT SAFETY CHECK\${NC}"
    echo ""

    # Check for uncommitted changes
    if ! git diff-index --quiet HEAD -- 2>/dev/null; then
        echo -e "\${RED}üö´ BLOCKED: Uncommitted changes detected\${NC}"
        echo ""
        echo "Modified files:"
        git status --short
        echo ""
        echo -e "\${RED}Dangerous command blocked: $COMMAND\${NC}"
        echo ""
        echo -e "\${GREEN}Safe alternatives:\${NC}"
        echo "  ‚Ä¢ git stash push -m 'before operation'"
        echo "  ‚Ä¢ /safe-switch <branch>  (for branch switching)"
        echo "  ‚Ä¢ /safe-reset <commit>   (for reset operations)"
        echo "  ‚Ä¢ /git-safety-status     (check full status)"
        echo ""
        exit 1
    fi

    # Check for untracked files that would be lost
    UNTRACKED=$(git ls-files --others --exclude-standard | wc -l)
    if [ "$UNTRACKED" -gt 0 ] && echo "$COMMAND" | grep -q "clean -fd"; then
        echo -e "\${RED}üö´ BLOCKED: $UNTRACKED untracked files would be deleted\${NC}"
        echo ""
        git ls-files --others --exclude-standard | head -10
        echo ""
        echo -e "\${YELLOW}Review these files before using git clean\${NC}"
        exit 1
    fi

    # Create automatic safety branch
    CURRENT_BRANCH=$(git branch --show-current)
    SAFETY_BRANCH="safety-\${CURRENT_BRANCH}-$(date +%Y%m%d-%H%M%S)"

    if git branch "$SAFETY_BRANCH" 2>/dev/null; then
        echo -e "\${GREEN}‚úÖ Safety backup created: $SAFETY_BRANCH\${NC}"
        echo "   (Delete later with: git branch -d $SAFETY_BRANCH)"
        echo ""
    fi
fi

# Allow command to proceed
exit 0
`;

// Command templates

const SAFE_SWITCH_TEMPLATE = `# /safe-switch

Switch branches safely with automatic stashing.

Usage: /safe-switch <branch-name>

## What this command does:
1. Shows current uncommitted changes
2. Automatically stashes them with descriptive message
3. Switches to target branch
4. Confirms switch and shows stash info for recovery

---

Check current status:
\`\`\`bash
echo "üìä Current Branch: $(git branch --show-current)"
echo ""
echo "Uncommitted changes:"
git status --short
echo ""
\`\`\`

Stash changes if they exist:
\`\`\`bash
if ! git diff-index --quiet HEAD --; then
    CURRENT_BRANCH=$(git branch --show-current)
    git stash push -m "Auto-stash from $CURRENT_BRANCH before switching to $ARGUMENTS"
    echo "üíæ Changes stashed"
else
    echo "‚úÖ No changes to stash"
fi
\`\`\`

Switch to target branch:
\`\`\`bash
git checkout "$ARGUMENTS"
\`\`\`

Confirm and show recovery info:
\`\`\`bash
echo ""
echo "‚úÖ Switched to: $(git branch --show-current)"
echo ""
echo "To recover your stashed work:"
git stash list | head -1
echo "Run: git stash pop"
\`\`\`
`;

const SAFE_COMMIT_TEMPLATE = `# /safe-commit

Commit with full awareness of repository state.

Usage: /safe-commit "<commit message>"

## Safety checks:
1. Shows ALL modified, staged, and untracked files
2. Shows what WILL be committed vs what WON'T
3. Warns about files you might have forgotten
4. Creates commit with your message

---

Show complete repository status:
\`\`\`bash
echo "üìä FULL REPOSITORY STATUS"
echo "========================="
echo ""

echo "üìç Current Branch: $(git branch --show-current)"
echo ""

echo "‚úÖ STAGED (will be committed):"
git diff --cached --stat
if [ -z "$(git diff --cached --stat)" ]; then
    echo "  (none)"
fi
echo ""

echo "‚ö†Ô∏è  MODIFIED (not staged, will NOT be committed):"
git diff --stat
if [ -z "$(git diff --stat)" ]; then
    echo "  (none)"
fi
echo ""

echo "‚ùì UNTRACKED (will NOT be committed):"
git ls-files --others --exclude-standard
if [ -z "$(git ls-files --others --exclude-standard)" ]; then
    echo "  (none)"
fi
echo ""
\`\`\`

Confirm scope:
\`\`\`bash
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "About to commit with message:"
echo "  \\"$ARGUMENTS\\""
echo ""

MODIFIED_COUNT=$(git diff --name-only | wc -l)
if [ "$MODIFIED_COUNT" -gt 0 ]; then
    echo "‚ö†Ô∏è  WARNING: $MODIFIED_COUNT modified files are NOT staged"
    echo "   These will NOT be included in the commit"
fi
\`\`\`

Create the commit:
\`\`\`bash
git commit -m "$ARGUMENTS"
echo ""
echo "‚úÖ Commit created successfully"
git log -1 --oneline
\`\`\`
`;

const SAFE_RESET_TEMPLATE = `# /safe-reset

Safe alternative to \`git reset --hard\`.

Usage: /safe-reset [commit]

Automatically creates backup branch before resetting.

---

Create safety backup:
\`\`\`bash
CURRENT_BRANCH=$(git branch --show-current)
BACKUP_BRANCH="backup-\${CURRENT_BRANCH}-$(date +%Y%m%d-%H%M%S)"

git branch "$BACKUP_BRANCH"
echo "‚úÖ Created backup branch: $BACKUP_BRANCH"
echo ""
\`\`\`

Show what will be lost:
\`\`\`bash
TARGET="\${ARGUMENTS:-HEAD}"
echo "‚ö†Ô∏è  Changes that will be DISCARDED:"
echo ""
git diff "$TARGET" --stat
echo ""
\`\`\`

Confirm operation:
\`\`\`bash
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "About to reset to: $TARGET"
echo "Backup available at: $BACKUP_BRANCH"
echo ""
echo "‚ö†Ô∏è  This will discard all uncommitted changes"
echo "Type 'yes' to proceed:"
read -r CONFIRM

if [ "$CONFIRM" != "yes" ]; then
    echo "‚ùå Reset cancelled"
    exit 0
fi
\`\`\`

Perform the reset:
\`\`\`bash
git reset --hard "$TARGET"
echo ""
echo "‚úÖ Reset complete"
echo ""
echo "üíæ To recover: git checkout $BACKUP_BRANCH"
\`\`\`
`;

const GIT_SAFETY_STATUS_TEMPLATE = `# /git-safety-status

Comprehensive git status check before operations.

Shows everything you need to know before any git operation.

---

\`\`\`bash
echo "üîç COMPREHENSIVE GIT STATUS"
echo "=============================="
echo ""

echo "üìç Current Branch:"
git branch --show-current
echo ""

echo "üìä Working Directory Status:"
git status --short
echo ""

echo "üíæ Stashed Changes:"
git stash list
if [ -z "$(git stash list)" ]; then
    echo "  (none)"
fi
echo ""

echo "üåø Recent Branches:"
git branch --sort=-committerdate | head -5
echo ""

echo "üîÑ Unpushed Commits:"
git log @{u}.. --oneline 2>/dev/null || echo "  (Branch not tracking remote)"
echo ""

echo "‚ö†Ô∏è  SAFETY WARNINGS:"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

# Check for many uncommitted changes
CHANGED_FILES=$(git diff --name-only | wc -l)
STAGED_FILES=$(git diff --cached --name-only | wc -l)
if [ "$CHANGED_FILES" -gt 10 ] || [ "$STAGED_FILES" -gt 10 ]; then
    echo "  ‚ö†Ô∏è  Large number of changes ($CHANGED_FILES modified, $STAGED_FILES staged)"
fi

# Check for untracked files
UNTRACKED=$(git ls-files --others --exclude-standard | wc -l)
if [ "$UNTRACKED" -gt 0 ]; then
    echo "  ‚ö†Ô∏è  $UNTRACKED untracked files"
fi

# Check if behind remote
git fetch --quiet 2>/dev/null
BEHIND=$(git rev-list --count HEAD..@{u} 2>/dev/null || echo "0")
if [ "$BEHIND" -gt 0 ]; then
    echo "  ‚ö†Ô∏è  $BEHIND commits behind remote"
fi

# Check if ahead of remote
AHEAD=$(git rev-list --count @{u}..HEAD 2>/dev/null || echo "0")
if [ "$AHEAD" -gt 0 ]; then
    echo "  ‚ÑπÔ∏è  $AHEAD unpushed commits"
fi

if [ "$CHANGED_FILES" -eq 0 ] && [ "$STAGED_FILES" -eq 0 ] && [ "$UNTRACKED" -eq 0 ]; then
    echo "  ‚úÖ Working directory clean"
fi

echo ""
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "Ready for git operations"
\`\`\`
`;

module.exports = {
  generateGitSafety,
  generateGitHooks,
  generateGitPermissions,
  generateSafeGitCommands,
  generateGitProtocol,
  GIT_SAFETY_HOOK_TEMPLATE
};
