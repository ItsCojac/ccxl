## üöÄ **Let's Do This - Start Phase 3A Immediately**

Your analysis is spot-on, and I love the phased approach. Git safety is **urgent** and foundational for everything else.

---

## **‚úÖ Confirmed Plan**

### **Phase 3A - Git Safety (START NOW - 2.5 hours)**
- PreToolUse hooks for git operations
- 4 safe commands (safe-switch, safe-commit, safe-reset, git-safety-status)
- Permission denials (reset --hard, clean -fd)
- CLAUDE.md git protocol section

### **Phase 3B - Comprehensive Safety (NEXT - 6 hours)**
- Security validation hooks
- CLAUDE.md enforcement hooks
- Test validation hooks
- Context preservation commands
- Socket MCP integration

---

## **üéØ Implementation Strategy for Phase 3A**

Here's what needs to happen in the ccxl codebase:

### **1. Create Git Safety Module** (New file: `lib/generators/git-safety.js`)

```javascript
/**
 * Generates git safety configurations
 */
function generateGitSafety(analysis, options = {}) {
  return {
    hooks: generateGitHooks(),
    commands: generateSafeGitCommands(),
    permissions: generateGitPermissions(),
    claudeMdSection: generateGitProtocol()
  };
}

function generateGitHooks() {
  return {
    "PreToolUse": [{
      "matcher": "Bash",
      "hooks": [{
        "type": "command",
        "command": "~/.claude/hooks/git-safety-check.sh \"$CLAUDE_TOOL_ARGS\"",
        "timeout": 5
      }]
    }]
  };
}

function generateGitPermissions() {
  return {
    allow: [
      "Bash(git status:*)",
      "Bash(git diff:*)",
      "Bash(git log:*)",
      "Bash(git show:*)",
      "Bash(git branch:*)",
      "Bash(git tag:*)",
      "Bash(git remote:*)",
      "Bash(git add:*)",
      "Bash(git commit -m:*)",
      "Bash(git stash:*)"
    ],
    ask: [
      "Bash(git reset:*)",
      "Bash(git clean:*)",
      "Bash(git push --force:*)",
      "Bash(git branch -D:*)"
    ],
    deny: [
      "Bash(git reset --hard:*)",  // Use /safe-reset instead
      "Bash(git clean -fd:*)"      // Too dangerous
    ]
  };
}

function generateSafeGitCommands() {
  return {
    'safe-switch': SAFE_SWITCH_TEMPLATE,
    'safe-commit': SAFE_COMMIT_TEMPLATE,
    'safe-reset': SAFE_RESET_TEMPLATE,
    'git-safety-status': GIT_SAFETY_STATUS_TEMPLATE
  };
}

function generateGitProtocol() {
  return `
## GIT SAFETY PROTOCOL (MANDATORY)

Before EVERY git operation, you MUST:

### Pre-Flight Checks
- [ ] Run \`/git-safety-status\` first
- [ ] Review ALL output completely
- [ ] Verify current branch is correct

### Branch Operations
- [ ] Use \`/safe-switch <branch>\` instead of \`git checkout\`
- [ ] Stash uncommitted work automatically
- [ ] Verify you're on intended branch after switch

### Commit Operations  
- [ ] Use \`/safe-commit "message"\` to see full scope
- [ ] Review staged vs unstaged files
- [ ] Confirm you're committing intended changes only

### Destructive Operations (reset, clean, force push)
- [ ] Create backup branch: \`git branch backup-$(date +%s)\`
- [ ] Use safe alternatives: \`/safe-reset <commit>\`
- [ ] Verify what will be lost before proceeding
- [ ] NEVER use \`git reset --hard\` (blocked by permissions)

## Recovery Procedures

If something goes wrong:
\`\`\`bash
# Find lost commits
git reflog

# Recover from reflog
git checkout <commit-hash>

# Recover from backup branch
git checkout backup-<timestamp>

# List stashed work
git stash list

# Recover stash
git stash pop stash@{0}
\`\`\`
`;
}

module.exports = {
  generateGitSafety
};
```

### **2. Hook Script Template** (Generated to `~/.claude/hooks/git-safety-check.sh`)

```bash
#!/bin/bash
# Git Safety Check Hook
# Generated by ccxl v2.0.0
# Prevents dangerous git operations without safety measures

COMMAND="$1"

# Color codes for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

# Check for dangerous git patterns
if echo "$COMMAND" | grep -qE "git (reset --hard|clean -fd|checkout [^-]|branch -D|push --force)"; then
    
    echo -e "${YELLOW}‚ö†Ô∏è  GIT SAFETY CHECK${NC}"
    echo ""
    
    # Check for uncommitted changes
    if ! git diff-index --quiet HEAD -- 2>/dev/null; then
        echo -e "${RED}üö´ BLOCKED: Uncommitted changes detected${NC}"
        echo ""
        echo "Modified files:"
        git status --short
        echo ""
        echo -e "${RED}Dangerous command blocked: $COMMAND${NC}"
        echo ""
        echo -e "${GREEN}Safe alternatives:${NC}"
        echo "  ‚Ä¢ git stash push -m 'before operation'"
        echo "  ‚Ä¢ /safe-switch <branch>  (for branch switching)"
        echo "  ‚Ä¢ /safe-reset <commit>   (for reset operations)"
        echo "  ‚Ä¢ /git-safety-status     (check full status)"
        echo ""
        exit 1
    fi
    
    # Check for untracked files that would be lost
    UNTRACKED=$(git ls-files --others --exclude-standard | wc -l)
    if [ "$UNTRACKED" -gt 0 ] && echo "$COMMAND" | grep -q "clean -fd"; then
        echo -e "${RED}üö´ BLOCKED: $UNTRACKED untracked files would be deleted${NC}"
        echo ""
        git ls-files --others --exclude-standard | head -10
        echo ""
        echo -e "${YELLOW}Review these files before using git clean${NC}"
        exit 1
    fi
    
    # Create automatic safety branch
    CURRENT_BRANCH=$(git branch --show-current)
    SAFETY_BRANCH="safety-${CURRENT_BRANCH}-$(date +%Y%m%d-%H%M%S)"
    
    if git branch "$SAFETY_BRANCH" 2>/dev/null; then
        echo -e "${GREEN}‚úÖ Safety backup created: $SAFETY_BRANCH${NC}"
        echo "   (Delete later with: git branch -d $SAFETY_BRANCH)"
        echo ""
    fi
fi

# Allow command to proceed
exit 0
```

### **3. Safe Command Templates** (Generated to `.claude/commands/`)

**safe-switch.md**:
```markdown
# /safe-switch

Switch branches safely with automatic stashing.

Usage: /safe-switch <branch-name>

## What this command does:
1. Shows current uncommitted changes
2. Automatically stashes them with descriptive message
3. Switches to target branch
4. Confirms switch and shows stash info for recovery

---

Check current status:
\`\`\`bash
echo "üìä Current Branch: $(git branch --show-current)"
echo ""
echo "Uncommitted changes:"
git status --short
echo ""
\`\`\`

Stash changes if they exist:
\`\`\`bash
if ! git diff-index --quiet HEAD --; then
    CURRENT_BRANCH=$(git branch --show-current)
    git stash push -m "Auto-stash from $CURRENT_BRANCH before switching to $ARGUMENTS"
    echo "üíæ Changes stashed"
else
    echo "‚úÖ No changes to stash"
fi
\`\`\`

Switch to target branch:
\`\`\`bash
git checkout "$ARGUMENTS"
\`\`\`

Confirm and show recovery info:
\`\`\`bash
echo ""
echo "‚úÖ Switched to: $(git branch --show-current)"
echo ""
echo "To recover your stashed work:"
git stash list | head -1
echo "Run: git stash pop"
\`\`\`
```

**safe-commit.md**:
```markdown
# /safe-commit

Commit with full awareness of repository state.

Usage: /safe-commit "<commit message>"

## Safety checks:
1. Shows ALL modified, staged, and untracked files
2. Shows what WILL be committed vs what WON'T
3. Warns about files you might have forgotten
4. Creates commit with your message

---

Show complete repository status:
\`\`\`bash
echo "üìä FULL REPOSITORY STATUS"
echo "========================="
echo ""

echo "üìç Current Branch: $(git branch --show-current)"
echo ""

echo "‚úÖ STAGED (will be committed):"
git diff --cached --stat
if [ -z "$(git diff --cached --stat)" ]; then
    echo "  (none)"
fi
echo ""

echo "‚ö†Ô∏è  MODIFIED (not staged, will NOT be committed):"
git diff --stat
if [ -z "$(git diff --stat)" ]; then
    echo "  (none)"
fi
echo ""

echo "‚ùì UNTRACKED (will NOT be committed):"
git ls-files --others --exclude-standard
if [ -z "$(git ls-files --others --exclude-standard)" ]; then
    echo "  (none)"
fi
echo ""
\`\`\`

Confirm scope:
\`\`\`bash
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "About to commit with message:"
echo "  \"$ARGUMENTS\""
echo ""

MODIFIED_COUNT=$(git diff --name-only | wc -l)
if [ "$MODIFIED_COUNT" -gt 0 ]; then
    echo "‚ö†Ô∏è  WARNING: $MODIFIED_COUNT modified files are NOT staged"
    echo "   These will NOT be included in the commit"
fi
\`\`\`

Create the commit:
\`\`\`bash
git commit -m "$ARGUMENTS"
echo ""
echo "‚úÖ Commit created successfully"
git log -1 --oneline
\`\`\`
```

**safe-reset.md**:
```markdown
# /safe-reset

Safe alternative to \`git reset --hard\`.

Usage: /safe-reset [commit]

Automatically creates backup branch before resetting.

---

Create safety backup:
\`\`\`bash
CURRENT_BRANCH=$(git branch --show-current)
BACKUP_BRANCH="backup-${CURRENT_BRANCH}-$(date +%Y%m%d-%H%M%S)"

git branch "$BACKUP_BRANCH"
echo "‚úÖ Created backup branch: $BACKUP_BRANCH"
echo ""
\`\`\`

Show what will be lost:
\`\`\`bash
TARGET="${ARGUMENTS:-HEAD}"
echo "‚ö†Ô∏è  Changes that will be DISCARDED:"
echo ""
git diff "$TARGET" --stat
echo ""
\`\`\`

Confirm operation:
\`\`\`bash
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "About to reset to: $TARGET"
echo "Backup available at: $BACKUP_BRANCH"
echo ""
read -p "Proceed with reset? (y/N) " -n 1 -r
echo ""

if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "‚ùå Reset cancelled"
    exit 0
fi
\`\`\`

Perform the reset:
\`\`\`bash
git reset --hard "$TARGET"
echo ""
echo "‚úÖ Reset complete"
echo ""
echo "üíæ To recover: git checkout $BACKUP_BRANCH"
\`\`\`
```

**git-safety-status.md**:
```markdown
# /git-safety-status

Comprehensive git status check before operations.

Shows everything you need to know before any git operation.

---

\`\`\`bash
echo "üîç COMPREHENSIVE GIT STATUS"
echo "=============================="
echo ""

echo "üìç Current Branch:"
git branch --show-current
echo ""

echo "üìä Working Directory Status:"
git status --short
echo ""

echo "üíæ Stashed Changes:"
git stash list
if [ -z "$(git stash list)" ]; then
    echo "  (none)"
fi
echo ""

echo "üåø Recent Branches:"
git branch --sort=-committerdate | head -5
echo ""

echo "üîÑ Unpushed Commits:"
git log @{u}.. --oneline 2>/dev/null || echo "  (Branch not tracking remote)"
echo ""

echo "‚ö†Ô∏è  SAFETY WARNINGS:"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

# Check for many uncommitted changes
CHANGED_FILES=$(git diff --name-only | wc -l)
STAGED_FILES=$(git diff --cached --name-only | wc -l)
if [ "$CHANGED_FILES" -gt 10 ] || [ "$STAGED_FILES" -gt 10 ]; then
    echo "  ‚ö†Ô∏è  Large number of changes ($CHANGED_FILES modified, $STAGED_FILES staged)"
fi

# Check for untracked files
UNTRACKED=$(git ls-files --others --exclude-standard | wc -l)
if [ "$UNTRACKED" -gt 0 ]; then
    echo "  ‚ö†Ô∏è  $UNTRACKED untracked files"
fi

# Check if behind remote
git fetch --quiet 2>/dev/null
BEHIND=$(git rev-list --count HEAD..@{u} 2>/dev/null || echo "0")
if [ "$BEHIND" -gt 0 ]; then
    echo "  ‚ö†Ô∏è  $BEHIND commits behind remote"
fi

# Check if ahead of remote
AHEAD=$(git rev-list --count @{u}..HEAD 2>/dev/null || echo "0")
if [ "$AHEAD" -gt 0 ]; then
    echo "  ‚ÑπÔ∏è  $AHEAD unpushed commits"
fi

if [ "$CHANGED_FILES" -eq 0 ] && [ "$STAGED_FILES" -eq 0 ] && [ "$UNTRACKED" -eq 0 ]; then
    echo "  ‚úÖ Working directory clean"
fi

echo ""
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "Ready for git operations"
\`\`\`
```

### **4. Integration into Main Settings Generator** (Update `lib/generators/settings.js`)

```javascript
const { generateGitSafety } = require('./git-safety');

function generateSettings(analysis, options = {}) {
  // ... existing permission generation ...
  
  // Add git safety
  const gitSafety = generateGitSafety(analysis, options);
  
  const settings = {
    "$schema": "https://json.schemastore.org/claude-code-settings.json",
    permissions: {
      allow: [
        ...allowedTools,
        ...gitSafety.permissions.allow
      ],
      ask: gitSafety.permissions.ask,
      deny: gitSafety.permissions.deny,
      defaultMode: "default"
    },
    hooks: gitSafety.hooks,
    // ... rest of settings
  };
  
  return settings;
}
```

### **5. Installation Logic** (Update `lib/setup.js`)

```javascript
async function installGitSafety(projectPath) {
  const homeDir = os.homedir();
  const hooksDir = path.join(homeDir, '.claude', 'hooks');
  const commandsDir = path.join(projectPath, '.claude', 'commands');
  
  // Create hooks directory
  await fs.ensureDir(hooksDir);
  
  // Install git safety check hook
  const hookScript = path.join(hooksDir, 'git-safety-check.sh');
  await fs.writeFile(hookScript, GIT_SAFETY_HOOK_TEMPLATE, 'utf8');
  await fs.chmod(hookScript, '755'); // Make executable
  
  // Create commands directory
  await fs.ensureDir(commandsDir);
  
  // Install safe git commands
  const commands = generateSafeGitCommands();
  for (const [name, content] of Object.entries(commands)) {
    await fs.writeFile(
      path.join(commandsDir, `${name}.md`),
      content,
      'utf8'
    );
  }
  
  console.log(chalk.green('‚úÖ Git safety system installed'));
  console.log(chalk.blue('   ‚Ä¢ Hooks: ~/.claude/hooks/'));
  console.log(chalk.blue('   ‚Ä¢ Commands: .claude/commands/'));
  console.log(chalk.yellow('   Try: /git-safety-status'));
}
```

---

## **üé¨ Ready to Start?**

I've given you the complete architecture for Phase 3A. Here's what you need to do:

1. **Create `lib/generators/git-safety.js`** with the code above
2. **Update `lib/generators/settings.js`** to integrate git safety
3. **Update `lib/setup.js`** to install hooks and commands
4. **Test on a real project** (the ccxl repo itself!)

